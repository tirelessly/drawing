package Manager;

import Bean.*;
import Manager.StrategyPattern.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class EditorManager extends AbstractFactory {


    private List<Shape> shapes = new ArrayList<>();
    private List<Observer> observers = new ArrayList<Observer>();
    private List <Integer> deletedId= new ArrayList<>();
    private final static AtomicInteger count  = new AtomicInteger(0);

    public EditorManager(){}

    @Override
    public List<Shape> getShapes() {
        return shapes;
    }


    /**
     * to change color by chosen id of shape. Id searched by Iterator
     * @param id
     * @param color
     */
    @Override
    public void changeColor(int id, String color) {
        Shape shape = getShapeIfExists(id);
        if(shape != null)
            new FillColorDecorator(shape, color);
        else{
            throw new IllegalArgumentException("There is no shape with such ID");
        }

    }

    /**
     * defines to which class belongs object args and appropriated object created
     * and added to list of shapes
     * id generated by method throw AtomicInteger
     * @param args
     */
    @Override
    void createShape(Object... args) {
        for(Object obj: args){
            System.out.println(obj);
        }
        Integer id=generateId();


        String shapeName = (String)args[0];
        if(shapeName.equalsIgnoreCase("Circle")) {
            try{
                shapes.add(new Circle(id, (List<Coordinates>) args[1], (Double)args[2], (String)args[3] ));
            } catch(IllegalArgumentException exception) {
                throw new IllegalArgumentException("Wrong parameters");
            }
        } else if(shapeName.equalsIgnoreCase("ellipse")) {
            try{
                shapes.add(new Ellipse(id, (List<Coordinates>) args[1], (Double)args[2], (Double) args[3], (String)args[4]));
            } catch(IllegalArgumentException exception) {
                throw new IllegalArgumentException("Wrong parameters");
            }
        } else if(shapeName.equalsIgnoreCase("line")) {
            try{
                shapes.add(new Line(id, (List<Coordinates>) args[1], (String)args[2]));
            } catch(IllegalArgumentException exception) {
                throw new IllegalArgumentException("Wrong parameters");
            }
        } else if(shapeName.equalsIgnoreCase("triangle")) {
            try{
                shapes.add(new Triangle(id, (List<Coordinates>) args[1], (String)args[2]));
            } catch(IllegalArgumentException exception) {
                throw new IllegalArgumentException("Wrong parameters");
            }
        } else if(shapeName.equalsIgnoreCase("text")) {
            try{
                shapes.add(new Text(id, (List<Coordinates>) args[1], (String)args[2], (String)args[3]));
            } catch(IllegalArgumentException exception) {
                throw new IllegalArgumentException("Wrong parameters");
            }
        } else if(shapeName.equalsIgnoreCase("quadrangle")) {
            try{
                shapes.add(new Quadrangle(id, (List<Coordinates>) args[1], (Double)args[2], (Double) args[3], (String)args[4]));
            } catch(IllegalArgumentException exception) {
                throw new IllegalArgumentException("Wrong parameters");
            }
        } else if(shapeName.equalsIgnoreCase("star")) {
            try{
                shapes.add(new Star(id, (List<Coordinates>) args[1], (String)args[2]));
            } catch(IllegalArgumentException exception) {
                throw new IllegalArgumentException("Wrong parameters");
            }
        } else if(shapeName.equalsIgnoreCase("ngon")) {
            try{
                shapes.add(new Ngon(id, (List<Coordinates>) args[1], (String)args[2]));
            } catch(IllegalArgumentException exception) {
                throw new IllegalArgumentException("Wrong parameters");
            }
        }
        else {
            throw new IllegalArgumentException("No shape found!");
        }

        notifyAllObservers(getShapes());

    }

    /**
     * uses shapeContainer to get Iterator and gets access the element by id of container
     * @param id
     * @return shape
     */

    public Shape getShapeIfExists(int id){
        ShapeContainerImpl shapeContainer= new ShapeContainerImpl(shapes);
        ShapeIterator iterator = shapeContainer.getIterator(id);
        while (iterator.hasNext()) {
            Shape shape = iterator.next();
            return shape;
        }
        return null;
    }

    /**
     * delete shape by id in List of shapes using method which calls Iterator to get access to container of shapes
     * deletes a shape from a layer, a function calls itself if "all" layer was chosen.
     * The id of deleted shapes saved in list
     * @param id
     */
    @Override
    public void deleteShape(int id){
        System.out.println("delete methode");
        LayerManager lm = new LayerManager();
            Shape shape = getShapeIfExists(id);
            if (shape != null)
                shapes.remove(shape);


            else {
                throw new IllegalArgumentException("There is no shape with such ID");
            }
            // for deledted ID
                deletedId.add(id);
                notifyAllObservers(getShapes());

        }


    /**
     * moves chosen Shape depending on chosen direction.
     * Movement distance of shape is standard: 50
     * @param id
     * @param direction
     */
    @Override
    void moveShape(int id, String direction) {
        Shape shape = getShapeIfExists(id);
        if (shape != null) {
            MoveContext ctx = new MoveContext();
            System.out.println("EM: " + direction);
            try {
                switch (direction) {
                    case "right":
                        ctx.setMoveStrategy(new MoveRight());
                        break;
                    case "left":
                        ctx.setMoveStrategy(new MoveLeft());
                        break;
                    case "up":
                        ctx.setMoveStrategy(new MoveUp());
                        break;
                    case "down":
                        ctx.setMoveStrategy(new MoveDown());
                        break;
                    default:
                        throw new IllegalArgumentException("Invalid Direction");
                }
            } catch (IllegalArgumentException e) {
                System.out.println(e);
            }

            try {
                ctx.moveShape(shape);
            } catch (IllegalArgumentException e) {
                System.out.print(e);
            }
        }
        else
        {
            throw new IllegalArgumentException("There is no shape with such ID or you didn't choose ID ");

        }
    }

    /**
     * scale Shape by chosen id of shape
     * @param id
     * @param measure
     */
    @Override
    public void scaleShape(int id, String measure) {
        for(Shape shape: getShapes()){
            if(shape.getId() == id){
                if(measure.equalsIgnoreCase("plus")){
                    shape.setScale(0.5);
                } else if(measure.equalsIgnoreCase("minus") && shape.getScale() - 0.5 >= 1.0){
                    shape.setScale(-0.5);
                } else
                    shape.setScale(0.0);
                break;
            }
        }

    }

    /**
     * to add additional observers
     * @param observer
     */
    public void attach(Observer observer){
        observers.add(observer);
    }

    public void notifyAllObservers(List<Shape> shapes){
        for(Observer observer: observers){
            observer.update();
        }
    }
    /**
     * collects all deleted id to reuse for new created Shapes
     * if there are no deleted IDs in List
     * than will be generated new ID using AtomicInteger
     * @return id
     */
    public int generateId(){
        int id = 0;
        if(deletedId.size()==0)
        {
            id=count.incrementAndGet();
        }
        else
        {
            id=deletedId.get(0);
            deletedId.remove(0);
        }
        return id;

    }






}
